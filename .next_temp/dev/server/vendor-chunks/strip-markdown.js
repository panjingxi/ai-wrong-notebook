"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/strip-markdown";
exports.ids = ["vendor-chunks/strip-markdown"];
exports.modules = {

/***/ "(ssr)/./node_modules/strip-markdown/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/strip-markdown/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ stripMarkdown)\n/* harmony export */ });\n/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').RootContent} RootContent\n * @typedef {import('mdast').Text} Text\n */\n\n/**\n * @callback Handler\n *   Transform a node.\n * @param {any} node\n *   Node.\n * @returns {Array<Nodes> | Nodes | null | undefined}\n *   Result.\n *\n * @typedef {Partial<Record<Nodes['type'], Handler>>} Handlers\n *   Handlers.\n *\n * @typedef Options\n *   Configuration.\n * @property {ReadonlyArray<Nodes['type']> | null | undefined} [keep]\n *   List of node types to leave unchanged (optional).\n * @property {ReadonlyArray<readonly [Nodes['type'], Handler] | Nodes['type']> | null | undefined} [remove]\n *   List of node types to remove (or replace, with handlers) (optional).\n */\n\n/**\n * Expose modifiers for available node types.\n * Node types not listed here are not changed (but their children are).\n *\n * @type {Handlers}\n */\nconst defaults = {\n  blockquote: children,\n  break: lineBreak,\n  code: empty,\n  definition: empty,\n  delete: children,\n  emphasis: children,\n  footnoteReference: empty,\n  footnoteDefinition: empty,\n  heading: paragraph,\n  html: empty,\n  image,\n  imageReference: image,\n  inlineCode: text,\n  list: children,\n  listItem: children,\n  link: children,\n  linkReference: children,\n  strong: children,\n  table: empty,\n  tableCell: empty,\n  text,\n  thematicBreak: empty,\n  // @ts-expect-error: custom frontmatter, sometimes defined with\n  // `remark-frontmatter`.\n  toml: empty,\n  yaml: empty\n}\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n/** @type {ReadonlyArray<Nodes['type']>} */\nconst emptyTypes = []\n\n/**\n * Remove markdown formatting.\n *\n * * remove `code`, `html`, `horizontalRule`, `table`, `toml`, `yaml`, and\n *   their content\n * * render everything else as simple paragraphs without formatting\n * * uses `alt` text for images\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nfunction stripMarkdown(options) {\n  const handlers = {...defaults}\n  const settings = options || emptyOptions\n  const keep = settings.keep || emptyTypes\n  const remove = settings.remove || emptyTypes\n\n  let index = -1\n\n  while (++index < remove.length) {\n    const value = remove[index]\n\n    if (typeof value === 'string') {\n      handlers[value] = empty\n    } else {\n      handlers[value[0]] = value[1]\n    }\n  }\n\n  /** @type {Handlers} */\n  let map = {}\n\n  if (keep.length === 0) {\n    map = handlers\n  } else {\n    /** @type {Nodes['type']} */\n    let key\n\n    for (key in handlers) {\n      if (!keep.includes(key)) {\n        map[key] = handlers[key]\n      }\n    }\n\n    index = -1\n\n    // Warn if unknown keys are turned off.\n    while (++index < keep.length) {\n      key = keep[index]\n\n      if (!Object.hasOwn(handlers, key)) {\n        throw new Error(\n          'Unknown node type `' +\n            key +\n            \"` in `keep`, use a replace tuple with a handle instead: `remove: [['\" +\n            key +\n            \"', handle]]`\"\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {Root} tree\n   *   Current tree.\n   * @returns {Root}\n   *   New tree.\n   */\n  return function (tree) {\n    // Cast as we assume root in -> root out.\n    const result = /** @type {Root} */ (one(tree))\n    return result\n  }\n\n  /**\n   * @param {Nodes} node\n   *   Node.\n   * @returns {Array<Nodes> | Nodes | undefined}\n   *   Result.\n   */\n  function one(node) {\n    /** @type {Nodes['type']} */\n    const type = node.type\n    /** @type {Array<Nodes> | Nodes | undefined} */\n    let result = node\n\n    if (Object.hasOwn(map, type)) {\n      const handler = map[type]\n      if (handler) result = handler(result) || undefined\n    }\n\n    result = Array.isArray(result) ? all(result) : result\n\n    if (result && 'children' in result) {\n      // @ts-expect-error: assume content models match.\n      result.children = all(result.children)\n    }\n\n    return result\n  }\n\n  /**\n   * @param {Array<Nodes>} nodes\n   *   Nodes.\n   * @returns {Array<Nodes>}\n   *   Result.\n   */\n  function all(nodes) {\n    let index = -1\n    /** @type {Array<Nodes>} */\n    const result = []\n\n    while (++index < nodes.length) {\n      const value = one(nodes[index])\n\n      if (Array.isArray(value)) {\n        result.push(...all(value))\n      } else if (value) {\n        result.push(value)\n      }\n    }\n\n    return clean(result)\n  }\n}\n\n/**\n * Clean nodes: merges literals.\n *\n * @param {Array<Nodes>} values\n *   Nodes.\n * @returns {Array<Nodes>}\n *   Results.\n */\nfunction clean(values) {\n  let index = -1\n  /** @type {Array<Nodes>} */\n  const result = []\n  /** @type {Nodes | undefined} */\n  let previous\n\n  while (++index < values.length) {\n    const value = values[index]\n\n    if (\n      previous &&\n      value.type === previous.type &&\n      'value' in value &&\n      'value' in previous\n    ) {\n      previous.value += value.value\n    } else {\n      result.push(value)\n      previous = value\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {Image | ImageReference} node\n *   Node.\n * @returns {Text | undefined}\n *   Result.\n * @satisfies {Handler}\n */\nfunction image(node) {\n  const title = 'title' in node ? node.title : ''\n  const value = node.alt || title || ''\n  return value ? {type: 'text', value} : undefined\n}\n\n/**\n * @param {InlineCode | Text} node\n *   Node.\n * @returns {Text}\n *   Result.\n * @satisfies {Handler}\n */\nfunction text(node) {\n  return {type: 'text', value: node.value}\n}\n\n/**\n * @param {Heading | Paragraph} node\n *   Node.\n * @returns {Paragraph}\n *   Result.\n * @satisfies {Handler}\n */\nfunction paragraph(node) {\n  return {type: 'paragraph', children: node.children}\n}\n\n/**\n * @param {Parents} node\n *   Parent.\n * @returns {Array<RootContent>}\n *   Node.\n * @satisfies {Handler}\n */\nfunction children(node) {\n  return node.children\n}\n\n/**\n * @returns {Text}\n *   Node.\n * @satisfies {Handler}\n */\nfunction lineBreak() {\n  return {type: 'text', value: '\\n'}\n}\n\n/**\n * @returns {undefined}\n *   Nothing.\n * @satisfies {Handler}\n */\nfunction empty() {\n  return undefined\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RyaXAtbWFya2Rvd24vbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsNkJBQTZCO0FBQzFDLGFBQWEsc0JBQXNCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFpRDtBQUMvRDtBQUNBLGNBQWMscUZBQXFGO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Ysb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGVBQWUsZUFBZTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEM7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2Qzs7QUFFQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkU6XFx3cm9uZy1ub3RlYm9va1xcbm9kZV9tb2R1bGVzXFxzdHJpcC1tYXJrZG93blxcbGliXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSGVhZGluZ30gSGVhZGluZ1xuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5JbWFnZX0gSW1hZ2VcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSW1hZ2VSZWZlcmVuY2V9IEltYWdlUmVmZXJlbmNlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLklubGluZUNvZGV9IElubGluZUNvZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuTm9kZXN9IE5vZGVzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlBhcmFncmFwaH0gUGFyYWdyYXBoXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlBhcmVudHN9IFBhcmVudHNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUm9vdH0gUm9vdFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5Sb290Q29udGVudH0gUm9vdENvbnRlbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGV4dH0gVGV4dFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEhhbmRsZXJcbiAqICAgVHJhbnNmb3JtIGEgbm9kZS5cbiAqIEBwYXJhbSB7YW55fSBub2RlXG4gKiAgIE5vZGUuXG4gKiBAcmV0dXJucyB7QXJyYXk8Tm9kZXM+IHwgTm9kZXMgfCBudWxsIHwgdW5kZWZpbmVkfVxuICogICBSZXN1bHQuXG4gKlxuICogQHR5cGVkZWYge1BhcnRpYWw8UmVjb3JkPE5vZGVzWyd0eXBlJ10sIEhhbmRsZXI+Pn0gSGFuZGxlcnNcbiAqICAgSGFuZGxlcnMuXG4gKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtSZWFkb25seUFycmF5PE5vZGVzWyd0eXBlJ10+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2tlZXBdXG4gKiAgIExpc3Qgb2Ygbm9kZSB0eXBlcyB0byBsZWF2ZSB1bmNoYW5nZWQgKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7UmVhZG9ubHlBcnJheTxyZWFkb25seSBbTm9kZXNbJ3R5cGUnXSwgSGFuZGxlcl0gfCBOb2Rlc1sndHlwZSddPiB8IG51bGwgfCB1bmRlZmluZWR9IFtyZW1vdmVdXG4gKiAgIExpc3Qgb2Ygbm9kZSB0eXBlcyB0byByZW1vdmUgKG9yIHJlcGxhY2UsIHdpdGggaGFuZGxlcnMpIChvcHRpb25hbCkuXG4gKi9cblxuLyoqXG4gKiBFeHBvc2UgbW9kaWZpZXJzIGZvciBhdmFpbGFibGUgbm9kZSB0eXBlcy5cbiAqIE5vZGUgdHlwZXMgbm90IGxpc3RlZCBoZXJlIGFyZSBub3QgY2hhbmdlZCAoYnV0IHRoZWlyIGNoaWxkcmVuIGFyZSkuXG4gKlxuICogQHR5cGUge0hhbmRsZXJzfVxuICovXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgYmxvY2txdW90ZTogY2hpbGRyZW4sXG4gIGJyZWFrOiBsaW5lQnJlYWssXG4gIGNvZGU6IGVtcHR5LFxuICBkZWZpbml0aW9uOiBlbXB0eSxcbiAgZGVsZXRlOiBjaGlsZHJlbixcbiAgZW1waGFzaXM6IGNoaWxkcmVuLFxuICBmb290bm90ZVJlZmVyZW5jZTogZW1wdHksXG4gIGZvb3Rub3RlRGVmaW5pdGlvbjogZW1wdHksXG4gIGhlYWRpbmc6IHBhcmFncmFwaCxcbiAgaHRtbDogZW1wdHksXG4gIGltYWdlLFxuICBpbWFnZVJlZmVyZW5jZTogaW1hZ2UsXG4gIGlubGluZUNvZGU6IHRleHQsXG4gIGxpc3Q6IGNoaWxkcmVuLFxuICBsaXN0SXRlbTogY2hpbGRyZW4sXG4gIGxpbms6IGNoaWxkcmVuLFxuICBsaW5rUmVmZXJlbmNlOiBjaGlsZHJlbixcbiAgc3Ryb25nOiBjaGlsZHJlbixcbiAgdGFibGU6IGVtcHR5LFxuICB0YWJsZUNlbGw6IGVtcHR5LFxuICB0ZXh0LFxuICB0aGVtYXRpY0JyZWFrOiBlbXB0eSxcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogY3VzdG9tIGZyb250bWF0dGVyLCBzb21ldGltZXMgZGVmaW5lZCB3aXRoXG4gIC8vIGByZW1hcmstZnJvbnRtYXR0ZXJgLlxuICB0b21sOiBlbXB0eSxcbiAgeWFtbDogZW1wdHlcbn1cblxuLyoqIEB0eXBlIHtSZWFkb25seTxPcHRpb25zPn0gKi9cbmNvbnN0IGVtcHR5T3B0aW9ucyA9IHt9XG4vKiogQHR5cGUge1JlYWRvbmx5QXJyYXk8Tm9kZXNbJ3R5cGUnXT59ICovXG5jb25zdCBlbXB0eVR5cGVzID0gW11cblxuLyoqXG4gKiBSZW1vdmUgbWFya2Rvd24gZm9ybWF0dGluZy5cbiAqXG4gKiAqIHJlbW92ZSBgY29kZWAsIGBodG1sYCwgYGhvcml6b250YWxSdWxlYCwgYHRhYmxlYCwgYHRvbWxgLCBgeWFtbGAsIGFuZFxuICogICB0aGVpciBjb250ZW50XG4gKiAqIHJlbmRlciBldmVyeXRoaW5nIGVsc2UgYXMgc2ltcGxlIHBhcmFncmFwaHMgd2l0aG91dCBmb3JtYXR0aW5nXG4gKiAqIHVzZXMgYGFsdGAgdGV4dCBmb3IgaW1hZ2VzXG4gKlxuICogQHBhcmFtIHtSZWFkb25seTxPcHRpb25zPiB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcmV0dXJuc1xuICogICBUcmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0cmlwTWFya2Rvd24ob3B0aW9ucykge1xuICBjb25zdCBoYW5kbGVycyA9IHsuLi5kZWZhdWx0c31cbiAgY29uc3Qgc2V0dGluZ3MgPSBvcHRpb25zIHx8IGVtcHR5T3B0aW9uc1xuICBjb25zdCBrZWVwID0gc2V0dGluZ3Mua2VlcCB8fCBlbXB0eVR5cGVzXG4gIGNvbnN0IHJlbW92ZSA9IHNldHRpbmdzLnJlbW92ZSB8fCBlbXB0eVR5cGVzXG5cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IHJlbW92ZS5sZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJlbW92ZVtpbmRleF1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBoYW5kbGVyc1t2YWx1ZV0gPSBlbXB0eVxuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyc1t2YWx1ZVswXV0gPSB2YWx1ZVsxXVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAdHlwZSB7SGFuZGxlcnN9ICovXG4gIGxldCBtYXAgPSB7fVxuXG4gIGlmIChrZWVwLmxlbmd0aCA9PT0gMCkge1xuICAgIG1hcCA9IGhhbmRsZXJzXG4gIH0gZWxzZSB7XG4gICAgLyoqIEB0eXBlIHtOb2Rlc1sndHlwZSddfSAqL1xuICAgIGxldCBrZXlcblxuICAgIGZvciAoa2V5IGluIGhhbmRsZXJzKSB7XG4gICAgICBpZiAoIWtlZXAuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBtYXBba2V5XSA9IGhhbmRsZXJzW2tleV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleCA9IC0xXG5cbiAgICAvLyBXYXJuIGlmIHVua25vd24ga2V5cyBhcmUgdHVybmVkIG9mZi5cbiAgICB3aGlsZSAoKytpbmRleCA8IGtlZXAubGVuZ3RoKSB7XG4gICAgICBrZXkgPSBrZWVwW2luZGV4XVxuXG4gICAgICBpZiAoIU9iamVjdC5oYXNPd24oaGFuZGxlcnMsIGtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdVbmtub3duIG5vZGUgdHlwZSBgJyArXG4gICAgICAgICAgICBrZXkgK1xuICAgICAgICAgICAgXCJgIGluIGBrZWVwYCwgdXNlIGEgcmVwbGFjZSB0dXBsZSB3aXRoIGEgaGFuZGxlIGluc3RlYWQ6IGByZW1vdmU6IFtbJ1wiICtcbiAgICAgICAgICAgIGtleSArXG4gICAgICAgICAgICBcIicsIGhhbmRsZV1dYFwiXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtSb290fSB0cmVlXG4gICAqICAgQ3VycmVudCB0cmVlLlxuICAgKiBAcmV0dXJucyB7Um9vdH1cbiAgICogICBOZXcgdHJlZS5cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiAodHJlZSkge1xuICAgIC8vIENhc3QgYXMgd2UgYXNzdW1lIHJvb3QgaW4gLT4gcm9vdCBvdXQuXG4gICAgY29uc3QgcmVzdWx0ID0gLyoqIEB0eXBlIHtSb290fSAqLyAob25lKHRyZWUpKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGVzfSBub2RlXG4gICAqICAgTm9kZS5cbiAgICogQHJldHVybnMge0FycmF5PE5vZGVzPiB8IE5vZGVzIHwgdW5kZWZpbmVkfVxuICAgKiAgIFJlc3VsdC5cbiAgICovXG4gIGZ1bmN0aW9uIG9uZShub2RlKSB7XG4gICAgLyoqIEB0eXBlIHtOb2Rlc1sndHlwZSddfSAqL1xuICAgIGNvbnN0IHR5cGUgPSBub2RlLnR5cGVcbiAgICAvKiogQHR5cGUge0FycmF5PE5vZGVzPiB8IE5vZGVzIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCByZXN1bHQgPSBub2RlXG5cbiAgICBpZiAoT2JqZWN0Lmhhc093bihtYXAsIHR5cGUpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gbWFwW3R5cGVdXG4gICAgICBpZiAoaGFuZGxlcikgcmVzdWx0ID0gaGFuZGxlcihyZXN1bHQpIHx8IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHJlc3VsdCA9IEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IGFsbChyZXN1bHQpIDogcmVzdWx0XG5cbiAgICBpZiAocmVzdWx0ICYmICdjaGlsZHJlbicgaW4gcmVzdWx0KSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhc3N1bWUgY29udGVudCBtb2RlbHMgbWF0Y2guXG4gICAgICByZXN1bHQuY2hpbGRyZW4gPSBhbGwocmVzdWx0LmNoaWxkcmVuKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PE5vZGVzPn0gbm9kZXNcbiAgICogICBOb2Rlcy5cbiAgICogQHJldHVybnMge0FycmF5PE5vZGVzPn1cbiAgICogICBSZXN1bHQuXG4gICAqL1xuICBmdW5jdGlvbiBhbGwobm9kZXMpIHtcbiAgICBsZXQgaW5kZXggPSAtMVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8Tm9kZXM+fSAqL1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG5vZGVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvbmUobm9kZXNbaW5kZXhdKVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goLi4uYWxsKHZhbHVlKSlcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsZWFuKHJlc3VsdClcbiAgfVxufVxuXG4vKipcbiAqIENsZWFuIG5vZGVzOiBtZXJnZXMgbGl0ZXJhbHMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxOb2Rlcz59IHZhbHVlc1xuICogICBOb2Rlcy5cbiAqIEByZXR1cm5zIHtBcnJheTxOb2Rlcz59XG4gKiAgIFJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGNsZWFuKHZhbHVlcykge1xuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge0FycmF5PE5vZGVzPn0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgLyoqIEB0eXBlIHtOb2RlcyB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IHByZXZpb3VzXG5cbiAgd2hpbGUgKCsraW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdXG5cbiAgICBpZiAoXG4gICAgICBwcmV2aW91cyAmJlxuICAgICAgdmFsdWUudHlwZSA9PT0gcHJldmlvdXMudHlwZSAmJlxuICAgICAgJ3ZhbHVlJyBpbiB2YWx1ZSAmJlxuICAgICAgJ3ZhbHVlJyBpbiBwcmV2aW91c1xuICAgICkge1xuICAgICAgcHJldmlvdXMudmFsdWUgKz0gdmFsdWUudmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgICBwcmV2aW91cyA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEBwYXJhbSB7SW1hZ2UgfCBJbWFnZVJlZmVyZW5jZX0gbm9kZVxuICogICBOb2RlLlxuICogQHJldHVybnMge1RleHQgfCB1bmRlZmluZWR9XG4gKiAgIFJlc3VsdC5cbiAqIEBzYXRpc2ZpZXMge0hhbmRsZXJ9XG4gKi9cbmZ1bmN0aW9uIGltYWdlKG5vZGUpIHtcbiAgY29uc3QgdGl0bGUgPSAndGl0bGUnIGluIG5vZGUgPyBub2RlLnRpdGxlIDogJydcbiAgY29uc3QgdmFsdWUgPSBub2RlLmFsdCB8fCB0aXRsZSB8fCAnJ1xuICByZXR1cm4gdmFsdWUgPyB7dHlwZTogJ3RleHQnLCB2YWx1ZX0gOiB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0lubGluZUNvZGUgfCBUZXh0fSBub2RlXG4gKiAgIE5vZGUuXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqICAgUmVzdWx0LlxuICogQHNhdGlzZmllcyB7SGFuZGxlcn1cbiAqL1xuZnVuY3Rpb24gdGV4dChub2RlKSB7XG4gIHJldHVybiB7dHlwZTogJ3RleHQnLCB2YWx1ZTogbm9kZS52YWx1ZX1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRpbmcgfCBQYXJhZ3JhcGh9IG5vZGVcbiAqICAgTm9kZS5cbiAqIEByZXR1cm5zIHtQYXJhZ3JhcGh9XG4gKiAgIFJlc3VsdC5cbiAqIEBzYXRpc2ZpZXMge0hhbmRsZXJ9XG4gKi9cbmZ1bmN0aW9uIHBhcmFncmFwaChub2RlKSB7XG4gIHJldHVybiB7dHlwZTogJ3BhcmFncmFwaCcsIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVufVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UGFyZW50c30gbm9kZVxuICogICBQYXJlbnQuXG4gKiBAcmV0dXJucyB7QXJyYXk8Um9vdENvbnRlbnQ+fVxuICogICBOb2RlLlxuICogQHNhdGlzZmllcyB7SGFuZGxlcn1cbiAqL1xuZnVuY3Rpb24gY2hpbGRyZW4obm9kZSkge1xuICByZXR1cm4gbm9kZS5jaGlsZHJlblxufVxuXG4vKipcbiAqIEByZXR1cm5zIHtUZXh0fVxuICogICBOb2RlLlxuICogQHNhdGlzZmllcyB7SGFuZGxlcn1cbiAqL1xuZnVuY3Rpb24gbGluZUJyZWFrKCkge1xuICByZXR1cm4ge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICdcXG4nfVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKiBAc2F0aXNmaWVzIHtIYW5kbGVyfVxuICovXG5mdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/strip-markdown/lib/index.js\n");

/***/ })

};
;